from pyteomics import mzxml, mzml, mass, auxiliary
from itertools import combinations_with_replacement
from .General_Functions import mz_int, count_seq_letters, sum_monos, calculate_comp_from_mass, gen_adducts_combo, comp_to_formula, sum_atoms, glycan_to_atoms, form_to_comp, calculate_isotopic_pattern, h_mass
from re import split
from math import inf
import sys
import datetime

##---------------------------------------------------------------------------------------
##File accessing-associated functions (these are functions that deal with the data in
##some way. They make vast use of general functions and require a library to work).

def eic_from_glycan(files,
                    glycan_info,
                    ms1_indexes,
                    tolerance):
    '''Generates an EIC of the mzs calculated for a glycan.

    Parameters
    ----------
    files : list
        A list of generators obtained from the function pyteomics.mzxml.MzXML().

    glycan_info : dict
        A dictionary containing multiple glycan info, including the needed 'Adducts_mz'
        key required for this function. Generated by full_glycans_library().

    ms1_indexes : dict
        A dictionary where each key is the ID of a file and each value is a list
        containing the indexes of all MS1 scans in the file.

    tolerance : float
        The mz acceptable tolerance.

    Uses
    ----
    mz_int() : float
        Extracts the intensity of the target mz within the given tolerance from a mz/int
        array dictionary.

    Returns
    -------
    data : dict
        A dictionary with keys for each adduct combo of a given glycan, which value is a
        dict with keys for each file id, at which value is a list of lists, with the
        first one being the rt array and the second one the int array.
    '''
    data = {}
    for i in glycan_info['Adducts_mz']:
        data[i] = {}
        for j_j, j in enumerate(files):
            data[i][j_j] = [[], []]
            for k in ms1_indexes[j_j]:
                mz_ints = dict(zip(j[k]['m/z array'], j[k]['intensity array']))
                rt = j[k]['retentionTime']
                intensity = mz_int(mz_ints, glycan_info['Adducts_mz'][i], tolerance)
                data[i][j_j][0].append(rt)
                data[i][j_j][1].append(intensity)
    return data

def peaks_from_eic(rt_int,
                   peak_width,
                   threshold,
                   rt_interval = (0, inf),
                   max_peaks = 3,
                   peak_relative_int = 0.5):
    '''Does multi-peak-picking in an EIC, based on the most intense peaks in the EIC,
    in the retention time interval of interest. This function works in-line.

    Parameters
    ----------
    rt_int : list
        A list containing two synchronized lists, the first one containing retention
        times and the second one containing intensity.

    peak_width : float
        The estimated peak width of interest peaks in your chromatographic run, in
        minutes.

    threshold : float
        The minimum intensity of a peak for it to be picked.

    rt_interval : tuple
        A tuple containing the retention time interval, in minutes at which you want to
        do peak-picking.
        Default = (0, 30)

    max_peaks : int
        Maximum amount of peaks to pick. Chooses the most intense peaks, and then the
        ones closer together. Good for isomers picking.
        Default = 3

    Returns
    -------
    max_list : list
        A list of dictionaries at which the keys are the peak id ('id'), retention time
        ('rt') and intensity ('int').

    peaks_interval : tuple
         A tuple of the rt interval at which all peaks were found
    '''
    max_list = []
    local_max = 0
    local_max_id = 0
    dormancy_id = 0
    for i_i, i in enumerate(rt_int[0]):
        if i_i >= dormancy_id and i >= rt_interval[0]:
            for j in range(i_i, len(rt_int[0])):
                if rt_int[0][j] >= i+peak_width:
                    temp_max = max(rt_int[1][i_i:j])
                    if temp_max > local_max:
                        local_max = temp_max
                        local_max_id = rt_int[1].index(temp_max)
                    if rt_int[0][j] >= (rt_int[0][local_max_id]+peak_width/2):
                        if local_max > threshold:
                            max_list.append({'id' : local_max_id,
                                            'rt' : rt_int[0][local_max_id],
                                            'int' : local_max})
                        local_max = 0
                        dormancy_id = j
                    break
        if i + peak_width > rt_int[0][-1] or i + peak_width > rt_interval[1]:
            if len(max_list) == 0:
                return max_list, (0, 0)
            max_list = sorted(max_list, key=lambda x: x['int'], reverse=True)[:max_peaks]
            peaks_interval = (max_list[0]['rt']-peak_width*max_peaks,
                              max_list[0]['rt']+peak_width*max_peaks)
            to_be_removed = []
            for i_i, i in enumerate(max_list):
                if i_i != 0:
                    if (abs(i['rt']-max_list[0]['rt']) > peak_width*max_peaks or
                        i['int'] < max_list[0]['int']*peak_relative_int):
                        to_be_removed.append(i)
            for i in to_be_removed:
                max_list.remove(i)
            return max_list, peaks_interval

def check_monoisotopic_charge(file,
                              ms1_indexes,
                              mz,
                              sec_iso_peak,
                              charges,
                              threshold,
                              peaks,
                              tolerance):
    '''Checks if the peaks identified for a given mz corresponds to monoisotopic,
    correctly charge-assigned peaks.

    Parameters
    ----------
    file : generator
        A  generator obtained from the function pyteomics.mzxml.MzXML().

    ms1_indexes : list
        A list of indexes of the MS1 spectra in the file.

    mz : float
        The mz of each you want to do the checks.

    charges : int
        The number of charges calculated for the given mz, to be checked.

    threshold : float
        The minimum intensity of previous peak to consider non-monoisotopic.

    peaks : list
        A list of dictionaries, each containing the peak id, rt and intensity as keys,
        with their respective values as values.

    Returns
    -------
    monoisotopic_state : list
        A list containing a boolean indicating if a mz at the corresponding peak is
        monoisotopic or not.

    charge_state : list
        A list containing a boolean indicating if a mz at the corresponding peak is
        correctly charge-assigned or not.
    '''
    monoisotopic_state = []
    charge_state = []
    for i in peaks:
        monoisotopic_state.append(True)
        charge_state.append(False)
        mz_int = 0
        for j_j, j in enumerate(file[ms1_indexes[i['id']]]['m/z array']):
            if abs(mz-j) <= tolerance:
                mz_int = file[ms1_indexes[i['id']]]['intensity array'][j_j]
            if j > mz+h_mass:
                break
            if (abs((mz-(h_mass/charges))-j) <= tolerance and
                file[ms1_indexes[i['id']]]['intensity array'][j_j] > threshold):
                monoisotopic_state[-1] = False
            if (abs((mz+(h_mass/charges))-j) <= tolerance  and 
                file[ms1_indexes[i['id']]]['intensity array'][j_j] > mz_int*(sec_iso_peak*0.8)):
                charge_state[-1] = True
                break
    return monoisotopic_state, charge_state

def deconvoluted_glycan_eic(file,
                           ms1_indexes,
                           isotopic_dist,
                           mz,
                           peaks_interval,
                           threshold, 
                           charges,
                           tolerance):
    '''Deconvolutes the data around the identified peaks retention time and creates a
    deconvoluted EIC.

    Parameters
    ----------
    file : generator
        A  generator obtained from the function pyteomics.mzxml.MzXML().

    ms1_indexes : list
        A list of indexes of the MS1 spectra in the file.

    isotopic_dist : list
        A list containing the intensoids of the isotopic distribution of the glycan.

    mz : float
        The mz of each you want to do the checks.

    peaks_interval : tuple
         A tuple of the rt interval at which all peaks were found.

    threshold : float
        The minimum intensity of a peak for it to be considered into the deconvolution.

    charges : int
        The number of charges calculated for the given mz, to be checked.

    tolerance : float
        The mz acceptable tolerance.

    Returns
    -------
    rt_int : list
        A list of lists, with the first one containing the rt array and the second one
        containing the intensity array.
    '''
    rt_int = [[], []]
    for i in ms1_indexes:
        peak = 0
        mono_int = 0.0
        temp_int = 0.0
        if file[i]['retentionTime'] > peaks_interval[1]:
            rt_int[0].append(file[i]['retentionTime'])
            rt_int[1].append(temp_int)
            continue
        elif file[i]['retentionTime'] > peaks_interval[0]:
            rt_int[0].append(file[i]['retentionTime'])
            for j_j, j in enumerate(file[i]['m/z array']):
                if j > mz+(h_mass/charges)*len(isotopic_dist):
                    break
                elif abs(mz-j) <= tolerance:
                    peak+=1
                    mono_int = file[i]['intensity array'][j_j]
                    temp_int+=file[i]['intensity array'][j_j]
                elif abs((mz+(h_mass/charges)*peak)-j) <= tolerance:
                    if (file[i]['intensity array'][j_j] > threshold and
                        peak < len(isotopic_dist)):
                        if (file[i]['intensity array'][j_j] >
                            mono_int*isotopic_dist[peak]):
                            temp_int+=mono_int*isotopic_dist[peak]
                        else:
                            temp_int+=file[i]['intensity array'][j_j]
                        peak+= 1
                    else:
                        break                    
        else:
            rt_int[0].append(file[i]['retentionTime'])
            rt_int[1].append(temp_int)
            continue
        rt_int[1].append(temp_int)
    return rt_int

def peaks_auc_from_eic(rt_int,
                 peaks,
                 peak_width):
    '''Calculates the area under curve of the picked peaks based on the EIC given.
    Overlapped portions of peaks are calculated as fractional proportion, based on peaks
    max intensity.

    Parameters
    ----------
    rt_int : list
        A list containing two synchronized lists, the first one containing retention
        times and the second one containing intensity.

    peaks : list
        A list of dictionaries, each containing the peak id, rt and intensity as keys,
        with their respective values as values.

    peak_width : float
        The estimated peak width of interest peaks in your chromatographic run, in
        minutes.

    Returns
    -------
    auc : list
        A list of AUCs, with each index containing a float of the AUC of a peak.
    '''
    auc = []
    for i in peaks:
        temp_auc = 0
        for j in range(i['id'], -1, -1):
            hit = False
            if rt_int[0][j] < rt_int[0][i['id']]-peak_width/2:
                break
            for k in peaks:
                if (k != i and
                    rt_int[0][k['id']] < rt_int[0][i['id']] and
                    rt_int[0][j] < rt_int[0][k['id']]+peak_width/2):
                    temp_auc+=rt_int[1][j]*(rt_int[1][i['id']]/
                                            (rt_int[1][k['id']]+rt_int[1][i['id']]))
                    hit = True
                    break
            if not hit:
                temp_auc+=rt_int[1][j]
        for j in range(i['id']+1, len(rt_int[0])):
            hit = False
            if rt_int[0][j] > rt_int[0][i['id']]+peak_width/2:
                break
            for k in peaks:
                if (k != i and
                    rt_int[0][k['id']] > rt_int[0][i['id']] and
                    rt_int[0][j] > rt_int[0][k['id']]-peak_width/2):
                    temp_auc+=rt_int[1][j]*(rt_int[1][i['id']]/
                                            (rt_int[1][k['id']]+rt_int[1][i['id']]))
                    hit = True
                    break
            if not hit:
                temp_auc+=rt_int[1][j]
        auc.append(temp_auc)
    return auc
